<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aviator Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #0a0a0a;
            color: white;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 30px;
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .history-section {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .counter-item {
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9rem;
            text-align: center;
            border: 2px solid;
            transition: all 0.3s ease;
            cursor: pointer;
            min-width: 60px;
        }

        .counter-item:hover {
            transform: scale(1.1);
        }

        .blueBorder {
            background: rgba(0, 123, 255, 0.2);
            border-color: #007bff;
            color: #007bff;
        }

        .purpleBorder {
            background: rgba(102, 16, 242, 0.2);
            border-color: #6610f2;
            color: #6610f2;
        }

        .burgundyBorder {
            background: rgba(220, 53, 69, 0.2);
            border-color: #dc3545;
            color: #dc3545;
        }

        .balance-display {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .balance-label {
            color: #888;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .balance-amount {
            background: #1a1a1a;
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 1.2rem;
            font-weight: bold;
            color: #fff;
            border: 1px solid #333;
        }

        .game-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            padding: 20px;
        }

        .canvas-container {
            width: 90%;
            max-width: 800px;
            height: 400px;
            background: #111;
            border-radius: 20px;
            position: relative;
            overflow: hidden;
            border: 1px solid #333;
            margin-bottom: 30px;
        }

        .graph-axes {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .axis-line {
            stroke: #333;
            stroke-width: 1;
        }

        .axis-label {
            fill: #666;
            font-size: 12px;
            font-family: Arial, sans-serif;
        }

        .time-label {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #666;
            font-size: 12px;
        }

        .multiplier-label {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%) rotate(-90deg);
            color: #666;
            font-size: 12px;
        }

        #canvas {
            width: 100%;
            height: 100%;
            border-radius: 20px;
            background: #000;
        }

        .multiplier-display {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 4rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.8);
            z-index: 10;
            animation: pulse 2s infinite;
        }

        .crash-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #ff4757, #e74c3c);
            padding: 25px 50px;
            border-radius: 8px;
            text-align: center;
            z-index: 20;
            box-shadow: 0 8px 25px rgba(255, 71, 87, 0.4);
            display: none;
        }

        .crash-multiplier {
            font-size: 42px;
            font-weight: bold;
            color: white;
            margin-bottom: 8px;
            line-height: 1;
        }

        .crash-text {
            font-size: 16px;
            font-weight: bold;
            color: white;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.95;
        }

        .countdown-bar {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 600px;
            background: #ff4757;
            padding: 20px 40px;
            text-align: center;
            z-index: 25;
            display: none;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(255, 71, 87, 0.4);
        }

        .countdown-content {
            display: block;
            color: white;
        }

        .countdown-icon {
            display: none;
        }

        .countdown-text {
            color: white;
            font-size: 20px;
            font-weight: bold;
            margin: 0;
            display: inline;
        }

        .countdown-timer {
            color: white;
            font-size: 20px;
            font-weight: bold;
            display: inline;
            margin-left: 8px;
        }

        /* Removed center countdown - using only Blaze-style countdown bar */

        @keyframes pulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.1); }
        }

        @keyframes explosion {
            0% { 
                transform: translateX(-50%) scale(1);
                opacity: 1;
            }
            25% { 
                transform: translateX(-50%) scale(1.5);
                opacity: 0.8;
            }
            50% { 
                transform: translateX(-50%) scale(2);
                opacity: 0.6;
            }
            75% { 
                transform: translateX(-50%) scale(2.5);
                opacity: 0.3;
            }
            100% { 
                transform: translateX(-50%) scale(3);
                opacity: 0;
            }
        }

        .explosion-effect {
            animation: explosion 1s ease-out;
        }

        .controls-container {
            display: flex;
            gap: 20px;
            align-items: center;
            width: 90%;
            max-width: 600px;
        }

        .bet-input-container {
            flex: 1;
            position: relative;
        }

        .bet-input {
            width: 100%;
            padding: 20px;
            font-size: 1.5rem;
            font-weight: bold;
            color: #fff;
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 50px;
            text-align: center;
            outline: none;
            transition: all 0.3s ease;
        }

        .bet-input:focus {
            border-color: #ff4757;
            box-shadow: 0 0 20px rgba(255, 71, 87, 0.3);
        }

        .currency-symbol {
            position: absolute;
            left: 25px;
            top: 50%;
            transform: translateY(-50%);
            color: #666;
            font-size: 1.2rem;
            pointer-events: none;
        }

        .bet-button {
            padding: 20px 60px;
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 10px 30px rgba(46, 204, 113, 0.4);
        }

        .bet-button:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(46, 204, 113, 0.6);
        }

        .bet-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .bet-button.cash-out {
            background: linear-gradient(135deg, #ff4757, #ff3742);
            box-shadow: 0 10px 30px rgba(255, 71, 87, 0.4);
        }

        .bet-button.cash-out:hover {
            box-shadow: 0 15px 40px rgba(255, 71, 87, 0.6);
        }

        .message-area {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            border-radius: 25px;
            font-weight: bold;
            font-size: 1.1rem;
            text-align: center;
            transition: all 0.3s ease;
            min-width: 300px;
        }

        .message-waiting {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
            border: 2px solid rgba(255, 193, 7, 0.4);
        }

        .message-flying {
            background: rgba(46, 213, 115, 0.2);
            color: #2ed573;
            border: 2px solid rgba(46, 213, 115, 0.4);
        }

        .message-crashed {
            background: rgba(255, 71, 87, 0.2);
            color: #ff4757;
            border: 2px solid rgba(255, 71, 87, 0.4);
        }

        .quick-bets {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 5;
        }

        .quick-bet {
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .quick-bet:hover {
            background: rgba(255, 71, 87, 0.3);
            border-color: #ff4757;
            transform: translateY(-2px);
        }

        .stats-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 20px;
            z-index: 5;
        }

        .stat-item {
            text-align: center;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #fff;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 15px;
                padding: 15px;
            }
            
            .history-section {
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .multiplier-display {
                font-size: 3rem;
            }
            
            .controls-container {
                flex-direction: column;
                width: 95%;
            }
            
            .bet-input {
                font-size: 1.2rem;
                padding: 15px;
            }
            
            .bet-button {
                width: 100%;
                padding: 15px;
                font-size: 1.2rem;
            }

            .stats-overlay {
                position: relative;
                top: auto;
                left: auto;
                justify-content: center;
                margin-bottom: 20px;
            }

            .quick-bets {
                position: relative;
                top: auto;
                right: auto;
                justify-content: center;
                margin-bottom: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="history-section" id="last-counters"></div>
        <div class="balance-display">
            <span class="balance-label">Saldo:</span>
            <div class="balance-amount" id="balance-amount">R$ 3.000,00</div>
        </div>
    </div>

    <div class="game-container">
        <div class="stats-overlay">
            <div class="stat-item">
                <div class="stat-value" id="total-bets">0</div>
                <div class="stat-label">Apostas</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="total-wins">0</div>
                <div class="stat-label">Vitórias</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="win-rate">0%</div>
                <div class="stat-label">Taxa</div>
            </div>
        </div>

        <div class="quick-bets">
            <button class="quick-bet" data-amount="50">R$ 50</button>
            <button class="quick-bet" data-amount="100">R$ 100</button>
            <button class="quick-bet" data-amount="250">R$ 250</button>
            <button class="quick-bet" data-amount="500">R$ 500</button>
        </div>

        <div class="canvas-container">
            <div class="multiplier-display" id="multiplier-display">1.00x</div>
            <div class="crash-display" id="crash-display">
                <div class="crash-multiplier" id="crash-multiplier">6,35X</div>
                <div class="crash-text">CRASHED</div>
            </div>
            <canvas id="canvas"></canvas>
        </div>


        <div class="controls-container">
            <div class="bet-input-container">
                <span class="currency-symbol">R$</span>
                <input type="number" class="bet-input" id="bet-input" step="1" value="100" placeholder="100">
            </div>
            <button class="bet-button" id="bet-button">Apostar</button>
        </div>
    </div>

    <div class="countdown-bar" id="countdown-bar">
        <div class="countdown-content">
            <div class="countdown-icon"></div>
            <span class="countdown-text">Começando em</span>
            <span class="countdown-timer" id="countdown-timer">8.5s</span>
        </div>
    </div>

    <script>
        class AviatorGame {
            constructor() {
                this.initializeElements();
                this.initializeGameState();
                this.initializeCanvas();
                this.initializeEventListeners();
                this.loadGameData();
                this.updateCounterDisplay();
                this.startGame();
            }

            initializeElements() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.multiplierDisplay = document.getElementById('multiplier-display');
                this.crashDisplay = document.getElementById('crash-display');
                this.crashMultiplierDisplay = document.getElementById('crash-multiplier');
                this.countdownBar = document.getElementById('countdown-bar');
                this.countdownTimer = document.getElementById('countdown-timer');
                this.balanceElement = document.getElementById('balance-amount');
                this.betButton = document.getElementById('bet-button');
                this.betInput = document.getElementById('bet-input');
                this.messageField = document.getElementById('message');
                this.lastCounters = document.getElementById('last-counters');
                this.totalBetsElement = document.getElementById('total-bets');
                this.totalWinsElement = document.getElementById('total-wins');
                this.winRateElement = document.getElementById('win-rate');
                
                // Create airplane image from SVG
                this.createAirplaneImage();
            }

            initializeGameState() {
                this.balance = 3000;
                this.currentMultiplier = 1.0;
                this.isFlying = false;
                this.hasPlacedBet = false;
                this.hasCashedOut = false;
                this.currentBetAmount = 0;
                this.animationId = null;
                this.countdownInterval = null;
                this.countdownTime = 0;
                this.isExploding = false;
                
                // Plane movement
                this.planeX = 0;
                this.planeY = 0;
                this.speedX = 3.5; // Increased horizontal speed for more diagonal trajectory
                this.dotPath = [];
                
                // Camera system
                this.cameraX = 0;
                this.cameraY = 0;
                this.cameraScale = 1.0; // Camera zoom level
                this.cameraFollowSpeed = 0.08; // Faster following for more responsive tracking
                this.cameraOffsetX = 0; // Keep plane centered horizontally
                this.cameraOffsetY = 0; // Keep plane centered vertically
                this.startingPoint = { x: 50, y: 0 }; // Remember starting point
                
                // Statistics
                this.stats = {
                    totalBets: 0,
                    totalWins: 0,
                    winRate: 0
                };
                
                // History
                this.counterHistory = [1.01, 18.45, 2.02, 5.21, 1.22, 1.25];
            }

            initializeCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                
                this.planeX = 50;
                this.planeY = this.canvas.height - 50;
                
                // Reset camera position
                this.cameraX = 0;
                this.cameraY = 0;
            }

            initializeEventListeners() {
                // Bet button
                this.betButton.addEventListener('click', () => this.handleBetButton());
                
                // Quick bet buttons
                document.querySelectorAll('.quick-bet').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const amount = e.target.dataset.amount;
                        this.betInput.value = amount;
                    });

                });
                
                // Input validation - only integers >= 5
                this.betInput.addEventListener('keydown', (e) => {
                    const invalidChars = ['-', '+', 'e', 'E', '.', ','];
                    if (invalidChars.includes(e.key)) {
                        e.preventDefault();
                    }
                });

                // Validate value on input change - only remove decimals, don't force minimum
                this.betInput.addEventListener('input', (e) => {
                    let value = parseInt(e.target.value);
                    
                    // Remove any decimal places but allow values below 5
                    if (!isNaN(value)) {
                        e.target.value = value.toString();
                    }
                });
            }

            calculateCrashChance() {
                // Blaze-style crash calculation: very low chance initially, then exponential
                if (this.currentMultiplier < 1.2) {
                    return 0.0001; // Almost impossible to crash before 1.2x
                }
                
                // Progressive crash chance that mimics Blaze behavior
                const multiplierFactor = this.currentMultiplier - 1;
                const exponentialFactor = Math.pow(multiplierFactor, 3.2); // More aggressive exponential
                const baseChance = 0.0008;
                
                return Math.min(baseChance * exponentialFactor, 0.15); // Max 15% chance per frame
            }

            startCountdown(duration, callback) {
                this.countdownTime = duration;
                this.countdownDisplay.textContent = this.countdownTime;
                this.countdownDisplay.style.display = 'block';
                this.multiplierDisplay.style.display = 'none';
                
                this.countdownInterval = setInterval(() => {
                    this.countdownTime--;
                    this.countdownDisplay.textContent = this.countdownTime;
                    
                    if (this.countdownTime <= 0) {
                        clearInterval(this.countdownInterval);
                        this.countdownDisplay.style.display = 'none';
                        this.multiplierDisplay.style.display = 'block';
                        callback();
                    }
                }, 1000);
            }

            updateDisplay() {
                this.multiplierDisplay.textContent = this.currentMultiplier.toFixed(2) + 'x';
                this.balanceElement.textContent = 'R$ ' + this.balance.toLocaleString('pt-BR', { 
                    minimumFractionDigits: 2, 
                    maximumFractionDigits: 2 
                });
                
                // Update multiplier color based on value
                if (this.currentMultiplier < 2) {
                    this.multiplierDisplay.style.color = '#fff';
                } else if (this.currentMultiplier < 5) {
                    this.multiplierDisplay.style.color = '#2ed573';
                } else if (this.currentMultiplier < 10) {
                    this.multiplierDisplay.style.color = '#ffa502';
                } else {
                    this.multiplierDisplay.style.color = '#ff4757';
                }
            }

            updateStats() {
                this.totalBetsElement.textContent = this.stats.totalBets;
                this.totalWinsElement.textContent = this.stats.totalWins;
                this.stats.winRate = this.stats.totalBets > 0 ? (this.stats.totalWins / this.stats.totalBets * 100) : 0;
                this.winRateElement.textContent = this.stats.winRate.toFixed(1) + '%';
            }

            updateCounterDisplay() {
                this.lastCounters.innerHTML = this.counterHistory.slice(0, 6).map(counter => {
                    let className = 'blueBorder';
                    if (counter >= 2 && counter < 10) className = 'purpleBorder';
                    else if (counter >= 10) className = 'burgundyBorder';
                    
                    return `<div class="counter-item ${className}">${counter}</div>`;
                }).join('');
            }

            handleBetButton() {
                if (this.hasPlacedBet && this.isFlying) {
                    this.cashOut();
                } else if (!this.isFlying && !this.isExploding) {
                    this.placeBet();
                }
            }

            placeBet() {
                const betAmount = parseInt(this.betInput.value);
                
                if (!betAmount || betAmount <= 0 || betAmount > this.balance || this.isFlying) {
                    // Simply do nothing - don't place bet for invalid amounts
                    return;
                }
                
                this.balance -= betAmount;
                this.currentBetAmount = betAmount;
                this.hasPlacedBet = true;
                this.hasCashedOut = false;
                this.stats.totalBets++;
                
                this.betButton.textContent = 'Retirar';
                this.betButton.classList.add('cash-out');
                this.setMessage(`Aposta: R$ ${betAmount.toLocaleString('pt-BR', { 
                    minimumFractionDigits: 2, 
                    maximumFractionDigits: 2 
                })}`, 'flying');
                
                this.updateDisplay();
                this.updateStats();
                this.saveGameData();
            }

            cashOut() {
                if (!this.hasPlacedBet || this.hasCashedOut) return;
                
                const winAmount = this.currentBetAmount * this.currentMultiplier;
                this.balance += winAmount;
                this.hasCashedOut = true;
                this.stats.totalWins++;
                
                this.betButton.textContent = 'Apostar';
                this.betButton.classList.remove('cash-out');
                this.setMessage(`Ganhou: R$ ${winAmount.toLocaleString('pt-BR', { 
                    minimumFractionDigits: 2, 
                    maximumFractionDigits: 2 
                })} (${this.currentMultiplier.toFixed(2)}x)`, 'flying');
                
                this.updateDisplay();
                this.updateStats();
                this.saveGameData();
            }

            setMessage(text, type = 'waiting') {
                // Messages removed - no longer displaying
            }

            // Function to interpolate between two colors
            interpolateColor(color1, color2, factor) {
                const result = color1.slice();
                for (let i = 0; i < 3; i++) {
                    result[i] = Math.round(result[i] + factor * (color2[i] - result[i]));
                }
                return result;
            }

            // Get smooth color transition based on multiplier
            getSmoothColor(multiplier) {
                // Define color stops [R, G, B]
                const red = [255, 71, 87];      // #ff4757
                const orange = [255, 165, 0];   // #ffa500  
                const gold = [255, 215, 0];     // #ffd700

                let color, alpha = 1;

                if (multiplier < 2) {
                    // Transition from red to orange (1x to 2x)
                    const factor = Math.max(0, Math.min(1, (multiplier - 1) / 1));
                    color = this.interpolateColor(red, orange, factor);
                } else if (multiplier < 5) {
                    // Transition from orange to gold (2x to 5x)
                    const factor = Math.max(0, Math.min(1, (multiplier - 2) / 3));
                    color = this.interpolateColor(orange, gold, factor);
                } else {
                    // Stay gold for 5x+
                    color = gold;
                }

                return {
                    solid: `rgb(${color[0]}, ${color[1]}, ${color[2]})`,
                    transparent: `rgba(${color[0]}, ${color[1]}, ${color[2]}, 0.3)`
                };
            }

            createAirplaneImage() {
                // Criando SVG que representa exatamente sua imagem
                const svgString = `
                <svg width="80" height="50" viewBox="0 0 500 300" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <style>
                            .plane-fill { fill: #dc2626; stroke: #dc2626; stroke-width: 1; }
                        </style>
                    </defs>
                    <!-- Fuselagem principal -->
                    <path class="plane-fill" d="M40 150 Q50 140 80 145 L380 150 Q420 150 450 160 Q470 170 480 185 Q485 200 475 215 Q460 230 420 235 L80 240 Q50 245 40 235 Z"/>
                    
                    <!-- Asa principal superior -->
                    <path class="plane-fill" d="M150 150 L100 80 Q90 70 80 75 Q70 80 75 90 L120 150 L300 145 L420 125 Q440 120 450 130 Q460 140 450 150 L300 155 L120 150 Z"/>
                    
                    <!-- Asa principal inferior -->
                    <path class="plane-fill" d="M150 235 L100 305 Q90 315 80 310 Q70 305 75 295 L120 235 L300 240 L420 260 Q440 265 450 255 Q460 245 450 235 L300 230 L120 235 Z"/>
                    
                    <!-- Cauda vertical -->
                    <path class="plane-fill" d="M40 150 L20 110 Q15 100 10 110 Q5 120 15 125 L35 150 L15 175 Q5 180 10 190 Q15 200 20 195 L40 170 Z"/>
                    
                    <!-- Hélice -->
                    <ellipse class="plane-fill" cx="480" cy="185" rx="15" ry="25"/>
                    
                    <!-- Cockpit -->
                    <ellipse class="plane-fill" cx="320" cy="190" rx="25" ry="15"/>
                    
                    <!-- Detalhes -->
                    <circle class="plane-fill" cx="300" cy="190" r="5"/>
                    <circle class="plane-fill" cx="280" cy="190" r="3"/>
                    <circle class="plane-fill" cx="260" cy="190" r="3"/>
                </svg>`;
                
                const blob = new Blob([svgString], {type: 'image/svg+xml;charset=utf-8'});
                const url = URL.createObjectURL(blob);
                
                this.airplaneImage = new Image();
                this.airplaneImage.onload = () => {
                    URL.revokeObjectURL(url);
                };
                this.airplaneImage.src = url;
            }

            updateCamera() {
                if (this.isFlying && !this.isExploding) {
                    // Simple camera follow - center on plane
                    const targetCameraX = this.planeX - this.canvas.width / 2;
                    const targetCameraY = this.planeY - this.canvas.height / 2;
                    
                    // Smoothly interpolate camera position
                    this.cameraX += (targetCameraX - this.cameraX) * this.cameraFollowSpeed;
                    this.cameraY += (targetCameraY - this.cameraY) * this.cameraFollowSpeed;
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw black background
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (!this.isFlying && !this.isExploding) return;
                
                // Save the current transformation matrix
                this.ctx.save();
                
                // Apply camera transformation (no scaling)
                this.ctx.translate(-this.cameraX, -this.cameraY);
                
                if (!this.isExploding) {
                    // Update plane position - Blaze-style trajectory
                    this.planeX += this.speedX;
                    
                    // Blaze-inspired trajectory: starts very flat, then exponential curve
                    const timeProgress = this.planeX / 200; // Time-based progress
                    const multiplierProgress = Math.log(this.currentMultiplier) / Math.log(10); // Logarithmic multiplier progress
                    
                    // Very flat start with exponential acceleration (like Blaze)
                    const flatStart = Math.pow(this.currentMultiplier - 1, 0.3) * 5; // Very gentle initial rise
                    const exponentialRise = Math.pow(this.currentMultiplier - 1, 2.8) * 35; // Strong exponential component
                    const timeBasedCurve = Math.pow(timeProgress, 1.5) * 15; // Time-based curvature
                    
                    this.planeY = this.canvas.height - 80 - flatStart - exponentialRise - timeBasedCurve;
                    
                    // Add to path
                    this.dotPath.push({ x: this.planeX, y: this.planeY });
                    
                    // Keep path length reasonable for performance
                    if (this.dotPath.length > 120) {
                        this.dotPath.shift();
                    }
                }
                
                // Draw trail with smooth color transitions
                if (this.dotPath.length > 1) {
                    this.ctx.lineWidth = 4;
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';
                    
                    // Draw the main line with smooth gradient effect
                    for (let i = 1; i < this.dotPath.length; i++) {
                        const progress = i / this.dotPath.length;
                        const intensity = Math.min(progress * 1.5, 1);
                        
                        // Get smooth color for current multiplier
                        const colors = this.getSmoothColor(this.currentMultiplier);
                        
                        // Apply intensity to the solid color for gradient effect
                        const rgbMatch = colors.solid.match(/rgb\((\d+), (\d+), (\d+)\)/);
                        if (rgbMatch) {
                            const [, r, g, b] = rgbMatch;
                            this.ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${intensity})`;
                        } else {
                            this.ctx.strokeStyle = colors.solid;
                        }
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(this.dotPath[i - 1].x, this.dotPath[i - 1].y);
                        this.ctx.lineTo(this.dotPath[i].x, this.dotPath[i].y);
                        this.ctx.stroke();
                    }
                }
                
                // Draw point with smooth color transitions
                if (this.isExploding) {
                    // Get smooth color for explosion
                    const colors = this.getSmoothColor(this.currentMultiplier);
                    
                    // Convert solid color to rgba with 0.5 opacity for explosion effect
                    const rgbMatch = colors.solid.match(/rgb\((\d+), (\d+), (\d+)\)/);
                    let explosionColorRgba = 'rgba(255, 71, 87, 0.5)';
                    if (rgbMatch) {
                        const [, r, g, b] = rgbMatch;
                        explosionColorRgba = `rgba(${r}, ${g}, ${b}, 0.5)`;
                    }
                    
                    // Draw explosion as larger circle
                    this.ctx.fillStyle = colors.solid;
                    this.ctx.beginPath();
                    this.ctx.arc(this.planeX, this.planeY, 15, 0, 2 * Math.PI);
                    this.ctx.fill();
                    
                    // Add pulsing effect for explosion
                    this.ctx.fillStyle = explosionColorRgba;
                    this.ctx.beginPath();
                    this.ctx.arc(this.planeX, this.planeY, 25, 0, 2 * Math.PI);
                    this.ctx.fill();
                } else if (this.isFlying) {
                    // Get smooth colors for the point
                    const colors = this.getSmoothColor(this.currentMultiplier);
                    
                    // Draw main point with smooth color
                    this.ctx.fillStyle = colors.solid;
                    this.ctx.beginPath();
                    this.ctx.arc(this.planeX, this.planeY, 8, 0, 2 * Math.PI);
                    this.ctx.fill();
                    
                    // Add glow effect with matching transparent color
                    this.ctx.fillStyle = colors.transparent;
                    this.ctx.beginPath();
                    this.ctx.arc(this.planeX, this.planeY, 12, 0, 2 * Math.PI);
                    this.ctx.fill();
                }
                
                // Restore the transformation matrix
                this.ctx.restore();
            }

            gameLoop() {
                if (!this.isFlying && !this.isExploding) return;
                
                if (!this.isExploding) {
                    // Update multiplier with Blaze-style acceleration
                    const baseIncrement = 0.004; // Slightly faster base increment
                    const acceleration = Math.pow(this.currentMultiplier - 1, 0.8) * 0.002; // Progressive acceleration
                    this.currentMultiplier += baseIncrement + acceleration;
                    
                    // Blaze-style crash probability - very low at start, exponential increase
                    const crashChance = this.calculateCrashChance();
                    if (Math.random() < crashChance) {
                        this.triggerCrash();
                        return;
                    }
                    
                    this.updateDisplay();
                }
                
                // Update camera to follow the plane
                this.updateCamera();
                
                this.draw();
                this.animationId = requestAnimationFrame(() => this.gameLoop());
            }

            triggerCrash() {
                this.isFlying = false;
                this.isExploding = true;
                
                // Hide multiplier display and show crash display
                this.multiplierDisplay.style.display = 'none';
                this.crashDisplay.style.display = 'block';
                this.crashMultiplierDisplay.textContent = this.currentMultiplier.toFixed(2).replace('.', ',') + 'X';
                
                // Handle losing bet
                if (this.hasPlacedBet && !this.hasCashedOut) {
                    this.setMessage(`Crashed em ${this.currentMultiplier.toFixed(2)}x - Perdeu R$ ${this.currentBetAmount.toLocaleString('pt-BR', { 
                        minimumFractionDigits: 2, 
                        maximumFractionDigits: 2 
                    })}`, 'crashed');
                } else {
                    this.setMessage(`Crashed em ${this.currentMultiplier.toFixed(2)}x`, 'crashed');
                }
                
                // Add to history
                this.counterHistory.unshift(parseFloat(this.currentMultiplier.toFixed(2)));
                this.counterHistory = this.counterHistory.slice(0, 6);
                
                this.updateCounterDisplay();
                this.saveGameData();
                
                // Show crash display for 2 seconds then hide and start countdown
                setTimeout(() => {
                    this.isExploding = false;
                    this.crashDisplay.style.display = 'none';
                    this.multiplierDisplay.style.display = 'block';
                    
                    // Clear the canvas completely
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    // Start countdown with bar
                    this.startCountdownWithBar();
                }, 2000);
            }

            startCountdownWithBar() {
                this.isCountingDown = true;
                let countdownTime = 3.0;
                this.countdownBar.style.display = 'block';
                this.countdownTimer.textContent = countdownTime.toFixed(1) + 's';
                
                const countdownInterval = setInterval(() => {
                    countdownTime -= 0.1;
                    this.countdownTimer.textContent = countdownTime.toFixed(1) + 's';
                    
                    if (countdownTime <= 0) {
                        clearInterval(countdownInterval);
                        this.countdownBar.style.display = 'none';
                        this.isCountingDown = false;
                        this.startNewRound();
                    }
                }, 100);
            }

            startNewRound() {
                this.currentMultiplier = 1.0;
                this.planeX = 50;
                this.planeY = this.canvas.height - 50;
                this.dotPath = [];
                this.hasPlacedBet = false;
                this.hasCashedOut = false;
                this.currentBetAmount = 0;
                
                // Reset camera position for new round
                this.cameraX = 0;
                this.cameraY = 0;
                
                this.betButton.textContent = 'Apostar';
                this.betButton.classList.remove('cash-out');
                this.setMessage('Aguarde a próxima rodada', 'waiting');
                
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Start flying immediately (countdown was handled by Blaze-style bar)
                this.startFlying();
            }

            startFlying() {
                this.isFlying = true;
                this.setMessage(this.hasPlacedBet ? 'Voando! Retire quando quiser' : 'Voando...', 'flying');
                this.gameLoop();
            }

            startGame() {
                this.setMessage('Preparando primeira rodada...', 'waiting');
                this.startCountdownWithBar();
            }

            saveGameData() {
                const gameData = {
                    balance: this.balance,
                    stats: this.stats,
                    counterHistory: this.counterHistory
                };
                this.savedData = gameData;
            }

            loadGameData() {
                if (this.savedData) {
                    this.balance = this.savedData.balance || 3000;
                    this.stats = this.savedData.stats || { totalBets: 0, totalWins: 0, winRate: 0 };
                    this.counterHistory = this.savedData.counterHistory || this.counterHistory;
                }
                this.updateDisplay();
                this.updateStats();
            }
        }

        // Initialize game when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new AviatorGame();
        });
    </script>
</body>
</html>
</html>